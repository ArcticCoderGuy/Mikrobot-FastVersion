"""
Validation System Integration
Complete integration of M5 BOS + M1 retest validation system
Orchestrates ProductOwner, U-Cell #1, ValidationOptimizer, DynamicRiskManager, and PerformanceMonitor
"""

from typing import Dict, Any, Optional, List
from datetime import datetime
import asyncio
import logging
from dataclasses import dataclass, asdict

from .product_owner_agent import ProductOwnerAgent
from .u_cells.signal_validation import SignalValidationCell
from .validation_optimizer import ValidationOptimizer, ValidationResult
from .dynamic_risk_manager import DynamicRiskManager, PositionSizingResult
from .performance_monitor import PerformanceMonitor
from .mcp_controller import MCPController

logger = logging.getLogger(__name__)


@dataclass
class IntegratedValidationResult:
    """Complete validation result with all components"""
    trace_id: str
    symbol: str
    pattern_type: str
    direction: str
    
    # Validation results
    validation_result: ValidationResult
    position_sizing_result: PositionSizingResult
    
    # Final decision
    final_approval: bool
    approval_reason: str
    rejection_reasons: List[str]
    
    # Performance metrics
    total_processing_time_ms: float
    validation_time_ms: float
    risk_calculation_time_ms: float
    
    # Quality metrics
    overall_confidence: float
    risk_level: str
    recommended_position_size: float
    expected_risk_reward: float
    
    timestamp: datetime


class ValidationSystemIntegration:
    """
    Complete M5 BOS + M1 retest validation system integration
    
    Architecture:
    1. ProductOwner Agent - Strategic decision making with enhanced price action validation
    2. U-Cell #1 (SignalValidationCell) - Advanced technical pattern recognition
    3. ValidationOptimizer - <100ms parallel validation coordination
    4. DynamicRiskManager - Confidence-based position sizing
    5. PerformanceMonitor - Quality metrics and performance tracking
    
    Features:
    - Sub-100ms total validation performance
    - Dynamic position sizing based on validation confidence
    - Comprehensive performance monitoring
    - Production-ready error handling and resilience
    """
    
    def __init__(self, mcp_controller: MCPController, account_balance: float = 10000.0):
        self.mcp_controller = mcp_controller
        
        # Initialize core components
        self.product_owner = ProductOwnerAgent()\n        self.validation_optimizer = ValidationOptimizer(mcp_controller, self.product_owner)\n        self.risk_manager = DynamicRiskManager(account_balance)\n        self.performance_monitor = PerformanceMonitor()\n        \n        # Register ProductOwner with MCP Controller\n        self.mcp_controller.register_agent(self.product_owner)\n        \n        # Integration metrics\n        self.integration_metrics = {\n            'total_signals_processed': 0,\n            'successful_integrations': 0,\n            'failed_integrations': 0,\n            'avg_total_processing_time_ms': 0.0,\n            'sub_100ms_achievement_rate': 0.0,\n            'high_confidence_approvals': 0,\n            'dynamic_risk_adjustments': 0\n        }\n        \n        # Configuration\n        self.config = {\n            'performance_target_ms': 100.0,\n            'min_confidence_threshold': 0.6,\n            'high_confidence_threshold': 0.85,\n            'enable_performance_monitoring': True,\n            'enable_dynamic_risk_sizing': True,\n            'enable_validation_caching': True\n        }\n        \n        logger.info(\"Validation System Integration initialized\")\n    \n    async def process_trading_signal_complete(self, signal_data: Dict[str, Any]) -> IntegratedValidationResult:\n        \"\"\"\n        Complete trading signal processing through integrated validation system\n        \n        Process Flow:\n        1. Parallel validation via ValidationOptimizer (<100ms target)\n        2. Dynamic position sizing via DynamicRiskManager\n        3. Performance monitoring and quality tracking\n        4. Final approval decision with comprehensive metrics\n        \n        Args:\n            signal_data: Complete signal data with price levels, market context, etc.\n        \n        Returns:\n            IntegratedValidationResult with complete processing results\n        \"\"\"\n        \n        import time\n        processing_start = time.perf_counter()\n        trace_id = signal_data.get('trace_id', f\"trace_{int(time.time() * 1000)}\")\n        \n        logger.info(f\"Processing signal {trace_id} through integrated validation system\")\n        \n        try:\n            self.integration_metrics['total_signals_processed'] += 1\n            \n            # Stage 1: Optimized parallel validation\n            validation_start = time.perf_counter()\n            validation_result = await self.validation_optimizer.validate_signal_optimized(\n                signal_data, trace_id\n            )\n            validation_time_ms = (time.perf_counter() - validation_start) * 1000\n            \n            # Record validation performance\n            if self.config['enable_performance_monitoring']:\n                self.performance_monitor.record_validation_performance(\n                    validation_time_ms=validation_result.validation_latency_ms,\n                    success=validation_result.overall_approved,\n                    confidence=validation_result.combined_confidence,\n                    pattern_type=signal_data.get('pattern_type', 'unknown'),\n                    cache_hit=validation_result.cache_hit,\n                    trace_id=trace_id\n                )\n            \n            # Initialize result structure\n            result = IntegratedValidationResult(\n                trace_id=trace_id,\n                symbol=signal_data.get('symbol', ''),\n                pattern_type=signal_data.get('pattern_type', ''),\n                direction=signal_data.get('direction', ''),\n                validation_result=validation_result,\n                position_sizing_result=None,\n                final_approval=False,\n                approval_reason='',\n                rejection_reasons=[],\n                total_processing_time_ms=0.0,\n                validation_time_ms=validation_time_ms,\n                risk_calculation_time_ms=0.0,\n                overall_confidence=validation_result.combined_confidence,\n                risk_level='unknown',\n                recommended_position_size=0.0,\n                expected_risk_reward=0.0,\n                timestamp=datetime.utcnow()\n            )\n            \n            # Check validation approval\n            if not validation_result.overall_approved:\n                result.rejection_reasons = validation_result.reasons\n                result.final_approval = False\n                \n                logger.info(f\"Signal {trace_id} rejected at validation stage: {validation_result.reasons}\")\n                \n                # Record performance and return early\n                result.total_processing_time_ms = (time.perf_counter() - processing_start) * 1000\n                self._update_integration_metrics(result)\n                return result\n            \n            # Stage 2: Dynamic position sizing (if validation passed)\n            if self.config['enable_dynamic_risk_sizing']:\n                risk_calc_start = time.perf_counter()\n                \n                # Extract position sizing parameters\n                price_levels = signal_data.get('price_levels', {})\n                entry_price = price_levels.get('entry', 0.0)\n                stop_loss_price = price_levels.get('stop_loss', 0.0)\n                take_profit_price = price_levels.get('take_profit', 0.0)\n                \n                if entry_price > 0 and stop_loss_price > 0 and take_profit_price > 0:\n                    # Calculate dynamic position size\n                    position_sizing_result = self.risk_manager.calculate_position_size(\n                        symbol=result.symbol,\n                        direction=result.direction,\n                        entry_price=entry_price,\n                        stop_loss_price=stop_loss_price,\n                        take_profit_price=take_profit_price,\n                        validation_confidence=validation_result.combined_confidence,\n                        validation_details=validation_result.details,\n                        market_data=signal_data.get('market_data', {}),\n                        trace_id=trace_id\n                    )\n                    \n                    result.position_sizing_result = position_sizing_result\n                    result.risk_level = position_sizing_result.risk_level.value\n                    result.recommended_position_size = position_sizing_result.position_size_lots\n                    result.expected_risk_reward = position_sizing_result.risk_reward_ratio\n                    \n                    # Check if position sizing rejected the trade\n                    if position_sizing_result.position_size_lots <= 0:\n                        result.final_approval = False\n                        result.rejection_reasons.extend(position_sizing_result.adjustments_applied)\n                        logger.info(f\"Signal {trace_id} rejected at position sizing stage\")\n                    else:\n                        result.final_approval = True\n                        result.approval_reason = f\"Approved with {position_sizing_result.position_size_lots} lots, confidence: {validation_result.combined_confidence:.2f}\"\n                        \n                        # Track high confidence approvals\n                        if validation_result.combined_confidence >= self.config['high_confidence_threshold']:\n                            self.integration_metrics['high_confidence_approvals'] += 1\n                        \n                        # Track dynamic risk adjustments\n                        if len(position_sizing_result.adjustments_applied) > 1:\n                            self.integration_metrics['dynamic_risk_adjustments'] += 1\n                \n                else:\n                    result.final_approval = False\n                    result.rejection_reasons.append(\"Invalid price levels for position sizing\")\n                    logger.warning(f\"Signal {trace_id} rejected: invalid price levels\")\n                \n                result.risk_calculation_time_ms = (time.perf_counter() - risk_calc_start) * 1000\n            \n            else:\n                # Position sizing disabled - approve based on validation only\n                result.final_approval = True\n                result.approval_reason = f\"Validation approved with confidence: {validation_result.combined_confidence:.2f}\"\n            \n            # Calculate total processing time\n            result.total_processing_time_ms = (time.perf_counter() - processing_start) * 1000\n            \n            # Update integration metrics\n            self._update_integration_metrics(result)\n            \n            # Log completion\n            if result.final_approval:\n                logger.info(f\"Signal {trace_id} APPROVED: {result.approval_reason} (processed in {result.total_processing_time_ms:.2f}ms)\")\n            else:\n                logger.info(f\"Signal {trace_id} REJECTED: {result.rejection_reasons}\")\n            \n            return result\n            \n        except Exception as e:\n            logger.error(f\"Integration error for signal {trace_id}: {str(e)}\")\n            \n            # Create error result\n            error_result = IntegratedValidationResult(\n                trace_id=trace_id,\n                symbol=signal_data.get('symbol', ''),\n                pattern_type=signal_data.get('pattern_type', ''),\n                direction=signal_data.get('direction', ''),\n                validation_result=None,\n                position_sizing_result=None,\n                final_approval=False,\n                approval_reason='',\n                rejection_reasons=[f'Integration error: {str(e)}'],\n                total_processing_time_ms=(time.perf_counter() - processing_start) * 1000,\n                validation_time_ms=0.0,\n                risk_calculation_time_ms=0.0,\n                overall_confidence=0.0,\n                risk_level='critical',\n                recommended_position_size=0.0,\n                expected_risk_reward=0.0,\n                timestamp=datetime.utcnow()\n            )\n            \n            self.integration_metrics['failed_integrations'] += 1\n            return error_result\n    \n    def _update_integration_metrics(self, result: IntegratedValidationResult):\n        \"\"\"Update integration performance metrics\"\"\"\n        \n        if result.final_approval:\n            self.integration_metrics['successful_integrations'] += 1\n        else:\n            self.integration_metrics['failed_integrations'] += 1\n        \n        # Update average processing time\n        total_processed = self.integration_metrics['total_signals_processed']\n        current_avg = self.integration_metrics['avg_total_processing_time_ms']\n        new_time = result.total_processing_time_ms\n        \n        self.integration_metrics['avg_total_processing_time_ms'] = (\n            (current_avg * (total_processed - 1)) + new_time\n        ) / total_processed\n        \n        # Update sub-100ms achievement rate\n        if result.total_processing_time_ms < 100.0:\n            # This is tracked across all processed signals\n            pass  # Will be calculated in get_metrics\n        \n        # Calculate sub-100ms rate\n        if total_processed > 0:\n            sub_100ms_count = sum(1 for _ in range(min(total_processed, 100)) \n                                if result.total_processing_time_ms < 100.0)  # Simplified\n            self.integration_metrics['sub_100ms_achievement_rate'] = sub_100ms_count / min(total_processed, 100)\n    \n    def record_trade_outcome(self, trace_id: str, actual_outcome: str, pnl: float):\n        \"\"\"Record actual trade outcome for quality tracking\"\"\"\n        \n        if self.config['enable_performance_monitoring']:\n            # This would typically be called after trade completion\n            # to track prediction accuracy\n            \n            # Extract pattern type and predicted outcome from trace_id or stored data\n            # For now, we'll use a simplified approach\n            \n            pattern_type = 'M5_BOS'  # Would be extracted from stored signal data\n            predicted_outcome = 'positive' if pnl > 0 else 'negative'\n            confidence = 0.8  # Would be extracted from stored validation result\n            \n            self.performance_monitor.record_trade_outcome(\n                pattern_type=pattern_type,\n                predicted_outcome=predicted_outcome,\n                actual_outcome=actual_outcome,\n                confidence=confidence,\n                pnl=pnl,\n                trace_id=trace_id\n            )\n    \n    def update_system_health(self, cpu_usage: float, memory_usage: float, \n                           active_connections: int = 0, queue_size: int = 0):\n        \"\"\"Update system health metrics\"\"\"\n        \n        if self.config['enable_performance_monitoring']:\n            self.performance_monitor.record_system_health(\n                cpu_usage=cpu_usage,\n                memory_usage=memory_usage,\n                active_connections=active_connections,\n                queue_size=queue_size\n            )\n    \n    def get_comprehensive_metrics(self) -> Dict[str, Any]:\n        \"\"\"Get comprehensive system metrics\"\"\"\n        \n        return {\n            'integration_metrics': self.integration_metrics,\n            'validation_optimizer_metrics': self.validation_optimizer.get_performance_metrics(),\n            'risk_manager_metrics': self.risk_manager.get_risk_metrics(),\n            'performance_monitor_metrics': self.performance_monitor.get_comprehensive_metrics(),\n            'product_owner_status': self.product_owner.get_comprehensive_status(),\n            'system_configuration': self.config\n        }\n    \n    def get_performance_report(self) -> Dict[str, Any]:\n        \"\"\"Generate comprehensive performance report\"\"\"\n        \n        # Get component reports\n        validation_report = self.validation_optimizer.get_performance_report()\n        risk_report = self.risk_manager.get_risk_report()\n        quality_report = self.performance_monitor.get_quality_report()\n        \n        # Calculate overall system grade\n        grades = [\n            validation_report.get('performance_grade', 'C'),\n            risk_report.get('risk_management_grade', 'C'),\n            quality_report.get('overall_quality_grade', 'C')\n        ]\n        \n        # Convert grades to numeric for averaging\n        grade_values = {'A+': 4.3, 'A': 4.0, 'B+': 3.3, 'B': 3.0, 'C+': 2.3, 'C': 2.0, 'D': 1.0, 'F': 0.0}\n        numeric_grades = [grade_values.get(grade, 2.0) for grade in grades]\n        avg_grade = sum(numeric_grades) / len(numeric_grades)\n        \n        # Convert back to letter grade\n        if avg_grade >= 4.0:\n            overall_grade = 'A'\n        elif avg_grade >= 3.5:\n            overall_grade = 'B+'\n        elif avg_grade >= 3.0:\n            overall_grade = 'B'\n        elif avg_grade >= 2.5:\n            overall_grade = 'C+'\n        elif avg_grade >= 2.0:\n            overall_grade = 'C'\n        else:\n            overall_grade = 'D'\n        \n        # Integration-specific metrics\n        total_processed = self.integration_metrics['total_signals_processed']\n        success_rate = 0.0\n        if total_processed > 0:\n            success_rate = self.integration_metrics['successful_integrations'] / total_processed\n        \n        # System recommendations\n        recommendations = []\n        \n        if self.integration_metrics['avg_total_processing_time_ms'] > 100.0:\n            recommendations.append(f\"Average processing time {self.integration_metrics['avg_total_processing_time_ms']:.1f}ms exceeds 100ms target\")\n        \n        if success_rate < 0.8:\n            recommendations.append(f\"Integration success rate {success_rate:.1%} below 80% target\")\n        \n        recommendations.extend(validation_report.get('recommendations', []))\n        recommendations.extend(risk_report.get('recommendations', []))\n        recommendations.extend(quality_report.get('recommendations', []))\n        \n        return {\n            'overall_system_grade': overall_grade,\n            'integration_success_rate': round(success_rate, 3),\n            'avg_processing_time_ms': round(self.integration_metrics['avg_total_processing_time_ms'], 2),\n            'sub_100ms_achievement_rate': round(self.integration_metrics['sub_100ms_achievement_rate'], 3),\n            'high_confidence_rate': round(\n                self.integration_metrics['high_confidence_approvals'] / max(total_processed, 1), 3\n            ),\n            'component_grades': {\n                'validation_performance': validation_report.get('performance_grade', 'C'),\n                'risk_management': risk_report.get('risk_management_grade', 'C'),\n                'quality_assurance': quality_report.get('overall_quality_grade', 'C')\n            },\n            'system_health': {\n                'validation_system_healthy': validation_report.get('system_health', {}).get('performance_stable', True),\n                'risk_management_healthy': risk_report.get('system_health', {}).get('within_risk_limits', True),\n                'monitoring_system_healthy': len(self.performance_monitor.active_alerts) == 0\n            },\n            'recommendations': recommendations[:10],  # Top 10 recommendations\n            'detailed_reports': {\n                'validation_optimizer': validation_report,\n                'risk_manager': risk_report,\n                'performance_monitor': quality_report\n            }\n        }\n    \n    def configure_system(self, config_updates: Dict[str, Any]):\n        \"\"\"Update system configuration\"\"\"\n        \n        self.config.update(config_updates)\n        logger.info(f\"System configuration updated: {config_updates}\")\n    \n    async def health_check(self) -> Dict[str, Any]:\n        \"\"\"Perform comprehensive system health check\"\"\"\n        \n        health_status = {\n            'timestamp': datetime.utcnow().isoformat(),\n            'overall_status': 'healthy',\n            'components': {}\n        }\n        \n        try:\n            # Check ProductOwner health\n            po_status = self.product_owner.get_comprehensive_status()\n            health_status['components']['product_owner'] = {\n                'status': 'healthy' if po_status['agent_info']['is_active'] else 'unhealthy',\n                'metrics': po_status['metrics']\n            }\n            \n            # Check ValidationOptimizer health\n            vo_metrics = self.validation_optimizer.get_performance_metrics()\n            vo_healthy = vo_metrics['validation_metrics']['performance_target_met_rate'] > 0.8\n            health_status['components']['validation_optimizer'] = {\n                'status': 'healthy' if vo_healthy else 'degraded',\n                'performance_target_met': vo_healthy\n            }\n            \n            # Check RiskManager health\n            rm_metrics = self.risk_manager.get_risk_metrics()\n            rm_healthy = rm_metrics['portfolio_state']['current_drawdown'] < 0.1\n            health_status['components']['risk_manager'] = {\n                'status': 'healthy' if rm_healthy else 'warning',\n                'within_risk_limits': rm_healthy\n            }\n            \n            # Check PerformanceMonitor health\n            pm_metrics = self.performance_monitor.get_comprehensive_metrics()\n            pm_healthy = len(pm_metrics['active_alerts']) < 5\n            health_status['components']['performance_monitor'] = {\n                'status': 'healthy' if pm_healthy else 'warning',\n                'active_alerts': len(pm_metrics['active_alerts'])\n            }\n            \n            # Determine overall status\n            component_statuses = [comp['status'] for comp in health_status['components'].values()]\n            if any(status == 'unhealthy' for status in component_statuses):\n                health_status['overall_status'] = 'unhealthy'\n            elif any(status in ['degraded', 'warning'] for status in component_statuses):\n                health_status['overall_status'] = 'degraded'\n            \n        except Exception as e:\n            logger.error(f\"Health check error: {str(e)}\")\n            health_status['overall_status'] = 'error'\n            health_status['error'] = str(e)\n        \n        return health_status\n    \n    async def shutdown(self):\n        \"\"\"Graceful system shutdown\"\"\"\n        \n        logger.info(\"Initiating validation system shutdown\")\n        \n        try:\n            # Export final metrics\n            final_metrics = self.get_comprehensive_metrics()\n            logger.info(f\"Final metrics: {self.integration_metrics}\")\n            \n            # Clear caches and cleanup\n            if hasattr(self.validation_optimizer, 'validation_cache'):\n                self.validation_optimizer.validation_cache.clear()\n            \n            if hasattr(self.performance_monitor, 'reset_metrics'):\n                # Don't reset, just clean up resources\n                pass\n            \n            logger.info(\"Validation system shutdown completed\")\n            \n        except Exception as e:\n            logger.error(f\"Error during shutdown: {str(e)}\")"